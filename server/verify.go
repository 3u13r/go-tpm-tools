package server

import (
	"crypto"
	"crypto/ecdsa"
	"crypto/rsa"
	"fmt"

	"github.com/google/go-tpm-tools/internal"
	pb "github.com/google/go-tpm-tools/proto/attest"
	tpmpb "github.com/google/go-tpm-tools/proto/tpm"
	"github.com/google/go-tpm/tpm2"
)

// VerifyOpts allows for customizing the functionality of VerifyAttestation.
type VerifyOpts struct {
	// The nonce used when calling client.Attest
	Nonce []byte
	// Trusted public keys that can be used to directly verify the key used for
	// attestation. This option should be used if you already know the AK.
	TrustedAKs []crypto.PublicKey
}

// VerifyAttestation performs the following checks on an Attestation:
//    - the AK used to generate the attestation is trusted (based on VerifyOpts)
//    - the provided signature is generated by the trusted AK public key
//    - the signature signs the provided quote data
//    - the quote data starts with TPM_GENERATED_VALUE
//    - the quote data is a valid TPMS_QUOTE_INFO
//    - the quote data was taken over the provided PCRs
//    - the provided PCR values match the quote data internal digest
//    - the provided opts.Nonce matches that in the quote data
//    - the provided eventlog matches the provided PCR values
//
// After this, the eventlog is parsed and the corresponding MachineState is
// returned. This design prevents unverified MachineStates from being used.
func VerifyAttestation(attestation *pb.Attestation, opts VerifyOpts) (*pb.MachineState, error) {
	// Verify the AK
	akPubArea, err := tpm2.DecodePublic(attestation.GetAkPub())
	if err != nil {
		return nil, fmt.Errorf("failed to decode AK public area: %w", err)
	}
	akPubKey, err := akPubArea.Key()
	if err != nil {
		return nil, fmt.Errorf("failed to get AK public key: %w", err)
	}
	if err = checkAkTrusted(akPubKey, opts); err != nil {
		return nil, err
	}

	// For now, we only verify SHA256 based Quotes, PCRs, and Events
	var quote *tpmpb.Quote
	for _, q := range attestation.GetQuotes() {
		if q.GetPcrs().GetHash() != tpmpb.HashAlgo_SHA256 {
			continue
		}
		quote = q
	}
	if quote == nil {
		return nil, fmt.Errorf("attestation does not contain a SHA256 quote")
	}
	// Verify the Quote
	if err = internal.VerifyQuote(quote, akPubKey, opts.Nonce); err != nil {
		return nil, fmt.Errorf("failed to verify quote: %w", err)
	}
	// Parse the event log and replay the events against the provided PCRs
	state, err := ParseAndReplayEventLog(attestation.GetEventLog(), quote.GetPcrs())
	if err != nil {
		return nil, fmt.Errorf("failed to validate the event log: %w", err)
	}
	return state, nil
}

func pubKeysEqual(k1 crypto.PublicKey, k2 crypto.PublicKey) bool {
	switch key := k1.(type) {
	case *rsa.PublicKey:
		return key.Equal(k2)
	case *ecdsa.PublicKey:
		return key.Equal(k2)
	default:
		return false
	}
}

// Checks if the provided AK public key can be trusted
func checkAkTrusted(ak crypto.PublicKey, opts VerifyOpts) error {
	if len(opts.TrustedAKs) == 0 {
		return fmt.Errorf("no mechanism for AK verification provided")
	}

	// Check against known AKs
	for _, trusted := range opts.TrustedAKs {
		if pubKeysEqual(ak, trusted) {
			return nil
		}
	}
	return fmt.Errorf("AK public key is not trusted")
}
